<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker 容器备份与迁移</title>
      <link href="/2024/12/09/%E6%95%99%E7%A8%8B/docker-container-backup/"/>
      <url>/2024/12/09/%E6%95%99%E7%A8%8B/docker-container-backup/</url>
      
        <content type="html"><![CDATA[<p>有时在 docker 中产生的数据，我们需要进行相应的备份和迁移到另一台服务器上，并在另一台服务器上进行数据恢复，docker 容器备份与迁移是在 docker 的镜像层级操作，我们介绍了三种容器备份与迁移的方法：</p><ul><li>离线迁移</li><li>DockerHub</li><li>私有镜像仓库</li></ul><p>首先我们需要将需要备份的容器打包成镜像。假设我们有一个容器，名为 <code>nvidia/cuda:11.6.0-cudnn8-devel-ubuntu18.04</code>，首先停止容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop nvidia_cuda</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090919653.png"></p><p>使用 <code>docker commit</code> 命令将该容器打包成镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;nvidia_cuda&quot; nvidia_cuda my_container:1.0</span><br></pre></td></tr></table></figure><p>可以看到我们生成的镜像信息，已成功制作镜像 <code>my_container:1.0</code></p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090920299.png"></p><h2 id="离线迁移"><a href="#离线迁移" class="headerlink" title="离线迁移"></a>离线迁移</h2><p>镜像文件经常有在服务器之间传输的需求，为此 docker 提供了镜像打包和镜像加载的命令，<code>docker save</code> 命令可将镜像打包成 <code>tar</code> 压缩文件，使用示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o my_container:1.0.tar my_container:1.0</span><br></pre></td></tr></table></figure><p>在当前目录下能生成 7.8G 的镜像压缩包 <code>my_container:1.0.tar</code></p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090921001.png" alt="image-20230525111125136"></p><p>之后需要将文件传输到其它主机上，在局域网内可实现高速传输，在压缩包所在目录打开 <code>http</code> 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 9000</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090921892.png"></p><p>监听服务器的 9000 号端口，如果显示端口被占用，换一个数字即可。</p><p>在浏览器中输入<code>10.24.83.40:9000</code>，找到我们的镜像压缩文件 <code>my_container:1.0.tar</code>，右键复制链接地址</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090922290.png"></p><p>在另一台主机上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget $&#123;刚才复制的地址&#125;</span><br></pre></td></tr></table></figure><p>文件开始传输（如果卡住刷新下浏览器就行，这种端口映射不支持并行传输）</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090922853.png"></p><p>至此，镜像压缩文件从一台主机传输到了另一台主机，之后需要从tar文件载入镜像。</p><p><code>docker load</code> 命令可以从tar文件载入镜像，执行示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i my_container:1.0.tar</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090922918.png"></p><p>查看镜像是否添加进 docker 里面：</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090923634.png"></p><p>然后使用 <code>docker run</code> 创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --gpus all --name my_container -v /mnt/data:/data -p 40000:40000 -p 40001:40001 -p 9000:22 my_container:1.0 /bin/bash</span><br></pre></td></tr></table></figure><p>可能能用上的参数说明：</p><ul><li>–gpus：容器内能使用GPU</li><li>–name：容器名称</li><li>-v：文件挂载，通常需要将主机上的机械硬盘目录挂载进容器内</li><li>-p：端口映射，9000:22表示将容器的22号端口映射到主机的9000号端口，用于容器的Shell连接，40000:40000表示将容器的40000号端口映射到主机的40000的端口，便于容器的局域网络服务</li></ul><p>容器启动成功：</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090929127.png"></p><p>在主机上运行设置容器自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start my_container</span><br><span class="line">docker update --restart=always my_container</span><br></pre></td></tr></table></figure><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>我们可以将自己制作的 docker 镜像发布至 <a href="https://hub.docker.com/">DockerHub</a> 公共仓库，需要科学上网才能进入，使用这种方式的核心命令：</p><ul><li><code>docker push</code>：用于将本地 docker 镜像上传到远程仓库，让其它用户可以使用</li><li><code>docker pull</code>：用于从 DockerHub 或其它镜像仓库中下载镜像到本地 docker 环境</li></ul><p>首先注册一个 DockerHub 账号，然后 <code>docker login</code> 命令使用 docker ID 和密码登录：</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090929227.png"></p><p>推送镜像至仓库，我们将 <code>my_container:1.0</code> 镜像拉取至本地，然后再上传至 DockerHub 仓库中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag my_container:1.0 lizhongliang123/my_container:1.0</span><br><span class="line">docker push lizhongliang123/my_container:1.0</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090930824.png"></p><p>可以看到镜像已经被push上去了：</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090930097.png"></p><p>我们在另一台主机上拉取镜像，测试镜像能否被拉取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull lizhongliang123/my_container:1.0</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090930502.png"></p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090931112.png"></p><p>使用完退出当前账号登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure><blockquote><p>后续容器的构建可以参考<a href="##%E7%A6%BB%E7%BA%BF%E8%BF%81%E7%A7%BB">离线迁移</a>后半部分的内容。</p></blockquote><h2 id="私有镜像仓库"><a href="#私有镜像仓库" class="headerlink" title="私有镜像仓库"></a>私有镜像仓库</h2><p>像 DockerHub、阿里云这样的公共镜像仓库有时候用起来不太方便，DockerHub 网速太慢，阿里云需要花钱买云主机；另外，涉及内部资源的保密性，有的机构不太可能将镜像提供给公网，因此需要创建一个基于内部项目的镜像，构造本地私人仓库供给团队使用。因此，docker 提供了 <a href="https://github.com/Joxit/docker-registry-ui">docker-registry</a> 工具，可以用于构建私有镜像仓库。</p><p><code>docker-registry</code> 工具也是个 docker 镜像，它的功能就是用于创建私服版的 DockerHub，使用 <code>docker-compose</code> 部署带有图形界面的 <code>docker-registry</code>，首先编写 <code>credentials.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir registry-ui</span><br><span class="line">cd registry-ui</span><br><span class="line">vim credentials.yml</span><br></pre></td></tr></table></figure><p>设置容器开机自启动，文件的内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry:2.7</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/data/registry:/var/lib/registry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-config/credentials.yml:/etc/docker/registry/config.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-config/htpasswd:/etc/docker/registry/htpasswd</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry-ui-net</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=厦门大学私有镜像仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NGINX_PROXY_PASS_URL=http://registry:5000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SINGLE_REGISTRY=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DELETE_IMAGES=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SHOW_CONTENT_DIGEST=true</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry-ui-net</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">registry-ui-net:</span></span><br></pre></td></tr></table></figure><p>新建鉴权配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir registry-config</span><br><span class="line">cd registry-config</span><br><span class="line">vim credentials.yml</span><br></pre></td></tr></table></figure><p>配置文件内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line">    <span class="attr">Access-Control-Allow-Origin:</span> [<span class="string">&#x27;http://localhost&#x27;</span>]</span><br><span class="line">    <span class="attr">Access-Control-Allow-Methods:</span> [<span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;OPTIONS&#x27;</span>, <span class="string">&#x27;DELETE&#x27;</span>]</span><br><span class="line">    <span class="attr">Access-Control-Allow-Headers:</span> [<span class="string">&#x27;Authorization&#x27;</span>, <span class="string">&#x27;Accept&#x27;</span>]</span><br><span class="line">    <span class="attr">Access-Control-Max-Age:</span> [<span class="number">1728000</span>]</span><br><span class="line">    <span class="attr">Access-Control-Allow-Credentials:</span> [<span class="literal">true</span>]</span><br><span class="line">    <span class="attr">Access-Control-Expose-Headers:</span> [<span class="string">&#x27;Docker-Content-Digest&#x27;</span>]</span><br><span class="line"><span class="attr">auth:</span></span><br><span class="line">  <span class="attr">htpasswd:</span></span><br><span class="line">    <span class="attr">realm:</span> <span class="string">basic-realm</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/etc/docker/registry/htpasswd</span></span><br></pre></td></tr></table></figure><p>添加密码文件，需要安装 <code>passwd</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apache2-utils</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -Bbn admin admin &gt; ./registry-config/htpasswd</span><br></pre></td></tr></table></figure><p>启动Registry服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f credentials.yml up -d</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090931700.png"></p><p>registry 映射到了 8080 号端口，访问 <a href="http://localhost:8080/">http://localhost:8080</a>&#x2F; 即可访问镜像仓库，默认用户名为 <code>admin</code>，密码为 <code>admin</code></p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090933325.png"></p><p>接下来需要向镜像仓库推送镜像，首先登录，用户名为 <code>admin</code>，密码为 <code>admin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">login后面如果不加地址默认是登录DockerHub</span></span><br><span class="line">docker login 10.24.83.22:8080</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090933229.png"></p><p><strong>一个bug：</strong>输入用户名和密码后出现错误</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090934842.png"><br>解决方法：<a href="ttps://blog.csdn.net/qcdh1234/article/details/100639420">https://blog.csdn.net/qcdh1234/article/details/100639420</a>，但是它是docker-compose的依赖库，需要login的时候就remove，不需要的时候就装回去：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker login</span><br><span class="line">sudo apt-get remove golang-docker-credential-helpers</span><br><span class="line"># docker-compose</span><br><span class="line">sudo apt-get install docker-compose</span><br></pre></td></tr></table></figure><p>接下来就是镜像推送，以registry镜像为例</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090934064.png"></p><p>首先打标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag registry:latest 10.24.83.22:8080/registry:latest</span><br></pre></td></tr></table></figure><p>然后就可以推送镜像了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 10.24.83.22:8080/registry:latest</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412090934501.png"></p><p>在局域网主机上使用docker pull可以从私有仓库中拉取镜像，在拉取镜像前，由于私服采用的是http协议，默认不被Docker信任，需要进行配置，改为https协议，使用docker pull的主机都需要修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开docker配置文件</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内容</span></span><br><span class="line">&quot;insecure-registries&quot;: [&quot;https://10.24.83.22:8080&quot;],</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>然后使用docker pull从私有仓库中拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 10.24.83.22:8080/registry:latest</span><br></pre></td></tr></table></figure><p><strong>鉴权</strong></p><p>若要修改用户名和密码，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -Bbn admin admin &gt; ./registry-config/htpasswd</span><br></pre></td></tr></table></figure><p>指定需要修改的用户名和密码。</p><p><strong>清空</strong></p><p>删除镜像在网页端操作，如果某个repos下面一个镜像都没有，需要采用删除文件夹的方式将0镜像的repos去除，镜像文件夹存储位置<code>/mnt/data/registry/docker/registry/v2/repositories/</code>。</p><p><strong>批量删除打标签10.24.83.22:8080”的镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep 10.24.83.22:8080 | awk &#x27;&#123;name=$1&quot;:&quot;$2;print name&#125;&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 基础</title>
      <link href="/2024/12/09/%E8%B0%83%E7%A0%94/docker-basics/"/>
      <url>/2024/12/09/%E8%B0%83%E7%A0%94/docker-basics/</url>
      
        <content type="html"><![CDATA[<p>docker 是一个基于 Go 语言开发的开源容器化平台，旨在通过轻量级、可移植的容器技术加速应用程序的交付并提高资源利用率。它秉承“构建一次，运行任何地方”的理念，利用 Linux 内核特性如命名空间（Namespaces）和控制组（Control Groups, cgroups）实现高效的资源隔离与限制，确保每个容器拥有独立的运行环境。docker 提供了一系列工具来简化应用的打包、分发和部署过程。例如，<code>Dockerfile</code> 定义了应用及其依赖的构建指令，而 <code>Docker Compose</code> 则允许用户定义和管理多容器应用的服务。这种设计使得开发者可以轻松创建出<strong>轻量、便携且自包含</strong>的容器，极大提升了开发效率和应用的一致性。</p><p><strong>应用容器（Application Container）</strong> 是 docker 的专业术语，指的是一种轻量级、自包含的软件包，它包含了应用程序及其所有依赖项，可以在任何环境中一致地运行。docker 容器的设计初衷就是为了让开发者能够“构建一次，运行任何地方”，即无论是在开发者的笔记本电脑、测试服务器还是生产环境，容器化应用的行为都是一致的。</p><p>总结来说，docker 通过其创新性的容器化技术，提供了一种比传统虚拟机更为轻量和高效的替代方案，特别适合于云原生应用和分布式系统的部署。它不仅简化了开发和运维工作，还提升了应用的可移植性和扩展性，成为现代软件开发不可或缺的一部分。</p><ul><li>镜像（Images）：docker 镜像是用于创建 docker 容器的模板</li><li>容器（Containers）：docker 容器是从 docker 镜像创建的运行实例</li><li>挂载（Mounting）：挂载是一种将宿主机的文件或目录在容器内部可见和可访问的方式，这种方式对于数据持久化和容器间数据共享十分重要</li></ul><h2 id="什么是-docker-容器"><a href="#什么是-docker-容器" class="headerlink" title="什么是 docker 容器"></a>什么是 docker 容器</h2><p>docker 是一种流行的开源软件平台，可简化创建、管理、运行和分发应用程序的过程。它使用容器打包应用程序及其依赖项，我们也可以将容器视为 Docker 镜像的运行实例。</p><h2 id="Docker-和虚拟机有何不同"><a href="#Docker-和虚拟机有何不同" class="headerlink" title="Docker 和虚拟机有何不同"></a>Docker 和虚拟机有何不同</h2><p>docker 是轻量级的沙盒，在其中运行的只是应用，虚拟机里面还有额外的系统。</p><p>相较于传统的虚拟机，docker 容器启动更快、占用更少的系统资源，并且能够更高效地共享主机的操作系统内核。此外，docker 采用客户端-服务器（C&#x2F;S）架构，借助远程 API 实现对容器生命周期的全面管理。其核心原则——<strong>构建（Build）、传输（Ship）、运行（Run）</strong>——贯穿于整个应用开发生命周期，支持从开发到生产的无缝过渡。</p><p>通过结合 Linux 内核的命名空间（Namespaces）和控制组（Cgroups），docker 实现了强大的资源隔离和限制，显著增强了容器的安全性和稳定性。这使得每个容器都能拥有独立的运行环境，同时共享主机的操作系统内核，避免了传统虚拟机带来的额外性能开销——后者通常会占用物理资源的 6-8%。</p><p>docker 为现代软件开发提供了一个灵活、高效且易于使用的解决方案，极大地推动了微服务架构和持续集成&#x2F;持续部署（CI&#x2F;CD）流程的发展。相较于需要完整操作系统实例的传统虚拟机，docker 容器启动速度更快、资源利用率更高，因为它们不包含操作系统层，而是依赖于宿主机的内核。</p><h2 id="什么是-DockerFile"><a href="#什么是-DockerFile" class="headerlink" title="什么是 DockerFile"></a>什么是 DockerFile</h2><p>Dockerfile 是一个文本文件，其中包含了我们需要运行以构建 docker 镜像的所有命令，每一条指令构建一层，每一条指令的内容用于描述该层应当如何构建。docker 使用 Dockerfile 中的指令自动构建镜像。</p><h3 id="示例-Dockerfile"><a href="#示例-Dockerfile" class="headerlink" title="示例 Dockerfile"></a>示例 Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的 Python 3.9 环境作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制当前目录下的所有文件到容器的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装应用所需的依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序运行的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义容器启动时执行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>一些常用的指令：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>FROM</td><td>建立基础镜像。在所有有效的 Dockerfile 中，FROM 是第一条指令</td></tr><tr><td>ENV</td><td>设置环境变量。这些变量可以在后续的构建步骤中使用，也可以在运行时由容器继承</td></tr><tr><td>RUN</td><td>执行命令行操作。通常会结合包管理工具（如 <code>apt-get</code>，<code>yum</code>）来安装必要的依赖</td></tr><tr><td>COPY</td><td>本地文件或目录复制到镜像中的指定位置</td></tr><tr><td>EXPOSE</td><td>声明容器运行时要监听的端口。虽然这不会自动打开端口，但它为运行容器的人提供了有关哪些端口应该被映射的信息</td></tr><tr><td>CMD</td><td>容器默认启动命令。如果用户在运行容器时没有提供其它命令，那么这个命令将会被执行</td></tr><tr><td>WORKDIR</td><td>设置工作目录。所有后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code> 和 <code>ADD</code> 指令都将在这个目录下执行。</td></tr><tr><td>LABEL</td><td>为镜像添加元数据，例如作者信息、版本号等</td></tr></tbody></table><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>要根据 Dockerfile 构建镜像，我们可以使用 <code>docker build</code> 用来创建按顺序执行多个命令行指令的自动创建。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-python-app .</span><br></pre></td></tr></table></figure><p>这里的 <code>-t</code> 参数用于给构建的镜像打上标签， <code>.</code> 表示 Dockerfile 所在的当前目录。</p><h2 id="Docker-Compose-如何保证容器-A-先于容器-B-运行"><a href="#Docker-Compose-如何保证容器-A-先于容器-B-运行" class="headerlink" title="Docker Compose 如何保证容器 A 先于容器 B 运行"></a>Docker Compose 如何保证容器 A 先于容器 B 运行</h2><p>Docker Compose 是一个用来定义和运行复杂应用的 docker 工具。一个应用通常由多个容器组成，使用 Docker Compose 将不再需要使用脚本来启动容器。Compose 通过一个配置文件来管理多个 Docker 容器。简单理解：Docker Compose 是 docker 的管理工具。</p><p>Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用 <code>depends_on</code> 条件，使用 <code>docker-compose up</code> 命令将按照我们指定的依赖顺序启动和运行服务。</p><p><code>depends_on</code> 指令用于定义服务之间的启动顺序。当使用 <code>docker-compose up</code> 命令时，Compose 会按照 <code>depends_on</code> 定义的依赖关系来启动服务。然而，<code>depends_on</code> 只确保指定的服务在逻辑上先被启动，并不等待这些服务完全初始化或变得可用</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-web-app</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>web</code> 服务会在 <code>db</code> 服务启动后启动，但这并不意味着 <code>web</code> 会等到 <code>db</code> 完全准备好了才开始启动。<code>web</code> 服务可能会在 <code>db</code> 服务还没有完全初始化的情况下尝试连接数据库，这可能导致连接失败。</p><h3 id="更严格的依赖控制"><a href="#更严格的依赖控制" class="headerlink" title="更严格的依赖控制"></a>更严格的依赖控制</h3><p>为了确保一个服务在另一个服务完全准备好后再启动，您可以采取以下几种方法</p><ul><li>健康检查（Health Checks）</li></ul><p>使用 docker 的 <code>healthcheck</code> 指令可以为服务定义健康检查的条件。只有当健康检查通过时，服务才会被视为“健康”。这样可以在后续服务启动时确保依赖的服务已准备好。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;pg_isready -U postgres&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-web-app</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">db:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>web</code> 服务将不会启动，直到 <code>db</code> 服务通过了健康检查。</p><ul><li>自定义脚本</li></ul><p>编写一个简单的脚本，在启动之前检查依赖服务的状态。例如，可以使用 <code>wait-for-it.sh</code> 或 <code>dockerize</code> 工具来等待特定端口或服务变得可用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-web-app</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;./wait-for-it.sh&quot;</span>, <span class="string">&quot;db:5432&quot;</span>, <span class="string">&quot;--&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>web</code> 服务会先运行 <code>wait-for-it.sh</code> 脚本来等待 <code>db</code> 服务的 5432 端口变得可用，然后再启动应用程序。</p><ul><li>重试机制</li></ul><p>在应用程序代码中实现重试机制，以处理依赖服务暂时不可用的情况。例如，如果应用程序尝试连接数据库失败，它可以等待几秒钟后再次尝试连接。</p><ul><li>第三方工具</li></ul><p> 还有一些第三方工具可以帮助管理复杂的依赖关系，如 <code>docker-wait</code> 和 <code>wait-for</code>。这些工具提供了更多的灵活性和功能来确保服务按正确的顺序启动并准备好</p><h2 id="docker-主要组成部分"><a href="#docker-主要组成部分" class="headerlink" title="docker 主要组成部分"></a>docker 主要组成部分</h2><ol><li>Docker Client（客户端）<ul><li><strong>定义</strong>：docker 客户端是用户与 docker 守护进程（Docker Daemon）交互的主要接口。它允许用户通过命令行工具 <code>docker</code> 或 <code>REST API</code> 发送请求给守护进程。</li><li><strong>功能</strong>：<ul><li>执行各种 docker 命令，如创建、启动、停止、删除容器等</li><li>管理镜像、网络、卷等资源</li><li>支持多种输出格式，包括 JSON、表格等，方便自动化脚本使用</li></ul></li></ul></li><li>Docker Daemon（守护进程）<ul><li><strong>定义</strong>：docker 守护进程（<code>dockerd</code>）是后台运行的服务，负责管理 docker 对象（如镜像、容器、网络和卷）。它是 docker 架构的核心组件，处理来自客户端的请求，并管理容器的生命周期。</li><li><strong>功能</strong>：<ul><li>接收来自客户端的指令并执行相应的操作</li><li>管理本地存储的镜像和容器</li><li>与注册表（Registry）通信以拉取或推送镜像</li><li>提供插件机制，支持扩展功能（如网络、存储驱动等）</li><li>监控容器的状态变化，并根据需要调整资源分配</li></ul></li></ul></li><li>Docker Image（镜像）<ul><li><strong>定义</strong>：docker 镜像是一个只读模板，包含了操作系统环境、应用代码及其依赖项。它是构建容器的基础，可以看作一个静态的应用程序包。</li><li><strong>功能</strong>：<ul><li>由一系列分层文件系统组成，每一层代表一个特定的更改或添加</li><li>可以基于现有的镜像进行定制，通过 Dockefile 定义构建过程</li><li>支持版本控制，每个镜像都有唯一的标签（tag），便于管理和追踪不同版本</li><li>可以从公共或私有的 Docker Registry 中获取，也可以本地构建</li></ul></li></ul></li><li>Docker Container（容器）<ul><li><strong>定义</strong>：</li><li><strong>功能</strong>：</li></ul></li><li>Docker Registry（注册表）<ul><li><strong>定义</strong>：</li><li><strong>功能</strong>：</li></ul></li><li>Docker Network（网络）<ul><li><strong>定义</strong>：</li><li><strong>功能</strong>：</li></ul></li><li>Docker Volume（卷）<ul><li><strong>定义</strong>：</li><li><strong>功能</strong>：</li></ul></li><li>Docker Compose<ul><li><strong>定义</strong>：</li><li><strong>功能</strong>：</li></ul></li><li>Docker Swarm 和 Kubernetes<ul><li><strong>定义</strong>：</li><li><strong>功能</strong>：</li></ul></li></ol><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><ol><li>查看本地主机的所用镜像：<code>docker images</code></li><li>搜索镜像：<code>docker search mysql</code></li><li>下载镜像：<code>docker pull mysql</code>，默认下载 latest 镜像</li><li>下载指定版本的镜像：<code>docker pull mysql:5.7</code></li><li>删除镜像：<code>docker rmi -f 镜像id 镜像id 镜像id</code></li></ol><h2 id="描述-Docker-容器生命周期"><a href="#描述-Docker-容器生命周期" class="headerlink" title="描述 Docker 容器生命周期"></a>描述 Docker 容器生命周期</h2><p>Docker 容器经历以下阶段：</p><ul><li>创建容器</li><li>运行容器</li><li>暂停容器（可选）</li><li>取消暂停容器（可选）</li><li>启动容器</li><li>停止容器</li><li>重启容器</li><li>杀死容器</li><li>销毁容器</li></ul><h2 id="Docker-容器间如何隔离"><a href="#Docker-容器间如何隔离" class="headerlink" title="Docker 容器间如何隔离"></a>Docker 容器间如何隔离</h2><p><strong>NameSpace 和 Cgroups</strong></p><p>Linux 中的 PID（进程 id）、IPC（进程间通信）、网络等资源是全局的，而 Linux 的 NameSpace 机制是一种资源隔离方案，在该机制下这些资源将不再是全局的，而是属于某个特定的 NameSpace，各个 NameSpace 下的资源互不干扰。</p><p><strong>NameSpace 实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容</strong>。对于宿主机来说，这些被“隔离”了的进程跟其它进程并没有区别。</p><p>虽然 NameSpace 技术可以实现资源隔离，但是进程还是可以不受控的访问系统资源，比如 CPU、内存、磁盘、网络等，为了控制容器进程对资源的访问，Docker 采用 control groups 技术（也就是 cgrous），有了 <code>cgroups</code> 就可以控制容器中进程对资源的访问，比如限制某个容器使用内存的上限、可以在哪些 CPU 上运行等等。</p><p>有了这两项技术，容器看起来就真的像是独立的操作系统了。</p>]]></content>
      
      
      <categories>
          
          <category> 调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FileBrowser 安装与部署</title>
      <link href="/2024/12/07/%E7%89%87%E6%AE%B5/docker-fileBrowser/"/>
      <url>/2024/12/07/%E7%89%87%E6%AE%B5/docker-fileBrowser/</url>
      
        <content type="html"><![CDATA[<p>​filebrowser 是一个使用go语言编写的软件，功能是可以通过浏览器对服务器上的文件进行管理。可以是修改文件，或者是添加删除文件，甚至可以分享文件，是一个很棒的文件管理器，你甚至可以当成一个网盘来使用。总之使用非常简单方便，功能很强大。</p><p>参考链接：</p><ul><li><p><a href="https://filebrowser.org/">FileBrowser 官网</a></p></li><li><p><a href="https://github.com/filebrowser/filebrowser">Github 链接</a></p></li></ul><h2 id="FileBrowser-安装"><a href="#FileBrowser-安装" class="headerlink" title="FileBrowser 安装"></a>FileBrowser 安装</h2><p>以下介绍 File Browser 的 Windows 安装方法，首先下载桌面版 docker-desktop，在终端命令行拉取镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull filebrowser/filebrowser:s6</span><br></pre></td></tr></table></figure><p>可以在 Docker Desktop 中查看拉取的镜像：</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412071851778.png"></p><p>在镜像界面点击运行按钮，进行容器配置：</p><p>指定容器名称为 fileBrowser，容器的端口为 8000，挂载卷添加三个挂载卷，前两个指定 filebrowser.db 和 settings.json 的位置，最后一个指定需要共享的文件夹的位置：</p><ul><li>&#x2F;path&#x2F;to&#x2F;filebrowser.db:&#x2F;database&#x2F;filebrowser.db</li><li>&#x2F;path&#x2F;to&#x2F;settings.json:&#x2F;config&#x2F;settings.json</li><li>&#x2F;path&#x2F;to&#x2F;root:&#x2F;srv</li></ul><p>settings.json 的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;port&quot;: 80,</span><br><span class="line">    &quot;baseURL&quot;: &quot;&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;log&quot;: &quot;stdout&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;filebrowser.db&quot;,</span><br><span class="line">    &quot;root&quot;: &quot;/srv&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filebrowser.db 从 10.24.83.22 主机获取。</p><p>共享文件夹位置为：E:\shareFiles，往里面添加的文件能在 fileBrowser 中看到。</p><p>最后两个环境变量添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-e PUID=$(id -u)</span><br><span class="line">-e PGID=$(id -g)</span><br></pre></td></tr></table></figure><p>点击 RUN 启动容器，容器启动界面：</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412071853599.png"></p><p>可以看到容器已经映射到 8000 号端口上了，在浏览器输入 <a href="http://10.26.35.38:8000/">10.26.35.38:8000</a> 即可打开共享文件管理目录，默认的用户名和密码均为 “admin”。</p><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412071853755.png"></p>]]></content>
      
      
      <categories>
          
          <category> 片段 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 核心语法</title>
      <link href="/2024/12/06/%E6%95%99%E7%A8%8B/vue3-grammar/"/>
      <url>/2024/12/06/%E6%95%99%E7%A8%8B/vue3-grammar/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 <code>vue3</code> 核心语法</p><h2 id="OptionsAPI-与-CompositionAPI"><a href="#OptionsAPI-与-CompositionAPI" class="headerlink" title="OptionsAPI 与 CompositionAPI"></a>OptionsAPI 与 CompositionAPI</h2><ul><li><code>Vue2</code> 的 <code>API</code> 设计是 <code>Options</code> （配置）风格的</li><li><code>Vue3</code> 的 <code>API</code> 设计师 <code>Composition</code> （组合）风格的</li></ul><p><code>Options API </code> 用于 Vue2 及之前的版本，通常用于组织 Vue 组件的代码。<code>Options API</code> 将一个组件分割成了几个部分，如<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>等，使得组件的逻辑可以分而治之，易于理解和维护。但随着项目的复杂度增加，<code>Options API</code> 逐渐显示出一些不足之处，如代码重复、逻辑难以复用等。</p><p><code>Composition API</code> 是 Vue3 引入的全新特性，它使用一种全新的方式来组织 Vue 组件的代码。与 <code>Options API</code> 相比，<code>Composition API</code> 更加灵活和可复用，可以将相关逻辑集中在一起，实现更好的代码组织和逻辑封装。通过 <code>Composition API</code>，我们可以更容易地实现代码复用和组件解耦，提高了组件的可维护性和可读性。</p><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>学习 <code>Vue3</code> 中的第一步。组合式 <code>API</code> 需要写进 <code>setup</code> 里面，组件中所用到的：数据、方法、计算属性、监视等，均配置在 <code>setup</code> 中。</p><blockquote><p>Vue3 的 setup 和 正常写 data、methods 有什么区别呢？</p><p>1、data 和 methods 可以和 setup 同时存在</p><p>2、data 和 methods 可以读取 setup 里面的数据，需使用 <code>this</code> 关键字</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&#x27;ts&#x27;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">WelcomeItem</span> <span class="keyword">from</span> <span class="string">&#x27;./WelcomeItem.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DocumentationIcon</span> <span class="keyword">from</span> <span class="string">&#x27;./icons/IconDocumentation.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ToolingIcon</span> <span class="keyword">from</span> <span class="string">&#x27;./icons/IconTooling.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">EcosystemIcon</span> <span class="keyword">from</span> <span class="string">&#x27;./icons/IconEcosystem.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CommunityIcon</span> <span class="keyword">from</span> <span class="string">&#x27;./icons/IconCommunity.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SupportIcon</span> <span class="keyword">from</span> <span class="string">&#x27;./icons/IconSupport.vue&#x27;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="响应式框架"><a href="#响应式框架" class="headerlink" title="响应式框架"></a>响应式框架</h2><p>vue2 的响应式数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="title class_">Vue2</span></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">x</span>:<span class="number">900</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue3 有两种方式：<code>ref</code> 和 <code>reactive</code></p><h3 id="ref-基本类型响应式数据"><a href="#ref-基本类型响应式数据" class="headerlink" title="ref -&gt; 基本类型响应式数据"></a>ref -&gt; 基本类型响应式数据</h3><p>定义响应式变量，哪个是响应式就给哪个加</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> age = <span class="title function_">ref</span>(<span class="string">&#x27;18&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在方法里面需要添加 <code>.value</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    name.<span class="property">value</span> = <span class="string">&#x27;zhang-san&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    age.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reactive-对象类型的响应式数据"><a href="#reactive-对象类型的响应式数据" class="headerlink" title="reactive -&gt; 对象类型的响应式数据"></a>reactive -&gt; 对象类型的响应式数据</h3><p>定义对象类型的响应式数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;dsadasdasd01&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;元&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;dsadasdasd02&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;新&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;dsadasdasd03&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;房&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changPrice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    car.<span class="property">price</span> += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeFirstGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    games[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;德&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ref-对象类型的响应式数据"><a href="#ref-对象类型的响应式数据" class="headerlink" title="ref -&gt; 对象类型的响应式数据"></a>ref -&gt; 对象类型的响应式数据</h3><p><code>ref</code> 也可以定义对象类型的响应式数据，<code>ref</code> 遇到对象类型时，底层找的是 <code>reactive</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="title function_">ref</span>(&#123;<span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> games = <span class="title function_">ref</span>([</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;dsadasdasd01&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;元&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;dsadasdasd02&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;新&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&#x27;dsadasdasd03&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;房&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changPrice</span>(<span class="params"></span>) &#123;</span><br><span class="line">    car.<span class="property">value</span>.<span class="property">price</span> += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeFirstGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    games.<span class="property">value</span>[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&#x27;德&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ref-对比-reactive"><a href="#ref-对比-reactive" class="headerlink" title="ref 对比 reactive"></a>ref 对比 reactive</h3><ul><li><code>ref</code> 创建的对象必须使用 <code>.value</code>（可以使用 <code>volar</code> 插件自动添加 <code>.value</code>）</li><li><code>reactive</code> 重新分配一个新对象，会<strong>失去</strong>响应式（可以使用 <code>Object.assign</code> 去整体替换）</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不是响应式数据</span></span><br><span class="line">    car = &#123;<span class="attr">brand</span>: <span class="string">&#x27;auto&#x27;</span>, <span class="attr">price</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">// 使用 Object.assign</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(car, &#123;<span class="attr">brand</span>: <span class="string">&#x27;auto&#x27;</span>, <span class="attr">price</span>: <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>若需要一个基本类型的响应式数据，必须使用 <code>ref</code></li><li>若需要一个响应式对象，层级不深，<code>ref</code> 和 <code>reactive</code> 都可以</li><li>若需要一个响应式对象，且层级较深，推荐使用 <code>reactive</code></li></ol><h2 id="toRefs-和-toRef"><a href="#toRefs-和-toRef" class="headerlink" title="toRefs 和 toRef"></a>toRefs 和 toRef</h2><ul><li><code>toRef</code>：复制 Reactive 里的单个属性并转换成 <code>ref</code></li><li><code>toRefs</code>：复制 Reactive 里的所有属性并转换成 <code>ref</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive, toRefs&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> nl = <span class="title function_">toRef</span>(person, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = <span class="title function_">toRefs</span>(person)</span><br></pre></td></tr></table></figure><p><code>toRefs</code> 的作用是把 Reactive 对象转换为 Ref 类型的响应式数据，解构数据使其具备响应式能力。</p><p>应用场景：移动鼠标并实时显示鼠标的位置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">usePostion</span>(<span class="params">state, x, y</span>) &#123;</span><br><span class="line">    <span class="comment">// 封装位置函数</span></span><br><span class="line">    <span class="keyword">let</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 绑定鼠标移动事件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">onMouseMove</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">        position.<span class="property">x</span> = event.<span class="property">x</span></span><br><span class="line">        position.<span class="property">y</span> = event.<span class="property">y</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove)</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(position)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收 x, y 位置</span></span><br><span class="line"><span class="keyword">let</span> &#123;x, y&#125; = <span class="title function_">usePosition</span>()</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    x, y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412062333030.gif"></p><p>案例中将提前封装好的 <code>usePosition</code> 函数通过 <code>toRefs</code> 返回一个响应式数据，然后直接拿来就用。在需要的地方引入进来即可，无需再重复声明。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>当我们需要将模板中的某一个数据进行一系列处理后得到一个新的值，虽然 Vue 的模板能够支持我们写一些表达式，但这样会使我们的模板变得更臃肿且不够灵活定制化。因此，Vue 推荐使用<code>计算属性（Computed）</code>来描述响应式状态的复杂逻辑。</p><p><code>Computed()</code> 接受一个 <code>getter 函数</code>，返回一个 <code>只读的响应式 ref 对象</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref, computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">let</span> firstName = <span class="title function_">ref</span>(<span class="string">&#x27;zhang&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="title function_">ref</span>(<span class="string">&#x27;san&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName 是计算属性，只可读不可改</span></span><br><span class="line"><span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="title function_">toUpperCase</span>() + firstName.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span> + lastName.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName 是计算属性，可读可改</span></span><br><span class="line"><span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="title function_">toUpperCase</span>() + firstName.<span class="property">value</span>.<span class="title function_">slice</span>(<span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span> + lastName.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [str1, str2] = val.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        firstName.<span class="property">value</span> = str1</span><br><span class="line">    lastName.<span class="property">value</span> = str2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    fullName.<span class="property">value</span> = <span class="string">&#x27;li-si&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算属性所依赖的数据发生变化它就重新计算。</p><blockquote><p>计算属性是有缓存的，方法是没有缓存的</p></blockquote><h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h2><ul><li>作用：监视数据的变化。</li><li>只能监视以下四种数据：</li></ul><blockquote><ol><li><code>ref</code> 定义的数据</li><li><code>reactive</code> 定义的数据</li><li>函数返回一个值</li><li>一个包含上述内容的数组</li></ol></blockquote><ul><li><code>ref</code> 监视代码：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">ref</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    sum.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">value</span>.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">value</span>.<span class="property">age</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changePerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">value</span> = &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">90</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监视【ref】定义的【基本类型】数据</span></span><br><span class="line"><span class="keyword">const</span> stopWatch = <span class="title function_">watch</span>(sum, (newValue, oldValue)) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum 变化了&#x27;</span>, newValue, oldValue)</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="title function_">stopWatch</span>()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监视【ref】定义的【对象类型】数据</span></span><br><span class="line"><span class="title function_">watch</span>(person, <span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person 变化了&#x27;</span>, newValue, oldValue)</span><br><span class="line">&#125;, &#123;<span class="attr">deep</span>:<span class="literal">true</span>, <span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>reactive</code> 监视代码：默认是深度监视</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive,watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">age</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changePerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Objext</span>.<span class="title function_">assign</span>(person, &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">80</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监视【reactive】定义的【对象类型】数据，默认开启深度监视</span></span><br><span class="line"><span class="title function_">watch</span>(person, <span class="function">(<span class="params">newValue, oldPerson</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person 变化了&#x27;</span>, newValue, oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>ref</code> 或 <code>reactive</code> 定义的【对象类型】数据中的某个属性</li></ul><p><code>getter</code> 函数：能放回一个值的函数</p><p>若该属性不是对象类型，则需要写成<code>函数</code>形式</p><p>若该属性依然是对象类型，建议写成 <code>函数</code> 形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive, watch&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">car</span>: &#123;</span><br><span class="line">    <span class="attr">c1</span>: <span class="string">&#x27;奔驰&#x27;</span>,</span><br><span class="line">    <span class="attr">c2</span>: <span class="string">&#x27;宝马&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">age</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeC1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">car</span>.<span class="property">c1</span> = <span class="string">&#x27;奥迪&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeC2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">car</span>.<span class="property">c2</span> = <span class="string">&#x27;大众&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeCar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    person.<span class="property">car</span> = &#123;<span class="attr">c1</span>: <span class="string">&#x27;雅迪&#x27;</span>, <span class="attr">c2</span>: <span class="string">&#x27;艾玛&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监视响应式对象中的【基本类型】属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span> person.<span class="property">name</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.name 发生变化了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监视响应式对象中的【对象类型】属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">car</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.car 发生变化了&#x27;</span>) </span><br><span class="line">&#125;, &#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>监视上述多个数据</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">name</span>, <span class="function">()=&gt;</span>person.<span class="property">car</span>.<span class="property">c1</span>], <span class="function">(<span class="params">newValue, oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;多个属性发生变化了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>在 <code>Vue3</code> 的组合式 API 中，回调函数 <code>()=&gt;&#123;&#125;</code> 是 <code>JavaScript</code> 的箭头函数语法，用于定义匿名函数。这些函数可以在各种上下文中使用，比如事件处理、定时器、<code>watch</code> 监听器等。<code>watch</code> 函数的回调是用来响应被监视数据的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> person.<span class="property">name</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person.name 发生变化了&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>watch</code> 的第一个参数<ul><li>第一个参数 <code>()=&gt;person.name</code> 是一个箭头函数，它没有参数列表（用空括号表示），并且直接返回 <code>person.name</code> 的当前值</li><li>这个函数会在每次 <code>person.name</code> 变化时被 <code>watch</code> 调用来获取最新的值</li></ul></li><li><code>watch</code> 的第二个参数<ul><li><code>watch</code> 的第二个参数是当被监视的数据发生变化时将执行的回调函数。这个回调函数接收两个参数：新的值和旧的值（如果你需要访问旧的值的话）。在例子中，回调函数并没有显式地声明参数，而是使用空的参数列表 <code>()</code> 并且只是简单打印了一条消息到控制台。</li><li>如果想访问新旧值，可以这么写：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新的值：&#x27;</span>, newValue)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧的值：&#x27;</span>, oldValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当 <code>person.name</code> 发生变化时，相应的 <code>watch</code> 监听器就会触发，并执行对应的回调函数。这使得你可以对这些变化作出反应，比如更新用户界面、发送网络请求、记录日志等。</p><ul><li>箭头函数 <code>()=&gt;&#123;&#125;</code> 在这里用作 <code>watch</code> 的参数，分别作为获取被监视数据的 <code>getter</code> 和当数据变化时执行的回调</li><li>回调函数允许你在数据变化时执行特定的逻辑，而不需要明确知道是什么导致了变化</li><li>使用 <code>deep:true</code> 可以确保即使对象内部的属性发生变化，也会触发监听器。</li></ul><h2 id="WatchEffect"><a href="#WatchEffect" class="headerlink" title="WatchEffect"></a>WatchEffect</h2>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly 主题</title>
      <link href="/2024/12/06/%E6%95%99%E7%A8%8B/hexo-butterfly-blog-themes/"/>
      <url>/2024/12/06/%E6%95%99%E7%A8%8B/hexo-butterfly-blog-themes/</url>
      
        <content type="html"><![CDATA[<p>本文讲述如何搭建 Butterfly 主题并快速美化我们的个人博客，好看的样式所产生的观感会让我们在阅读时有一种心情愉悦的感觉。这里，我们介绍一些简单的配置，更多的配置可以跟着官方配置的方法。许多你需要解决的问题都可以在 (Butterfly 主题官网)[<a href="https://butterfly.js.org/]%E6%89%BE%E5%88%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://butterfly.js.org/]找到解决方案。</a></p><h2 id="导航目录"><a href="#导航目录" class="headerlink" title="导航目录"></a>导航目录</h2><p><img src="https://lzl-hexo-blog.oss-cn-hangzhou.aliyuncs.com/img/202412062044455.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.butterfly.yml</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">目录</span> <span class="string">||</span> <span class="attr">fas fa-list:</span></span><br><span class="line">    <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">娱乐</span> <span class="string">||</span> <span class="attr">fa fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">图库:</span> <span class="string">/gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">工具:</span> <span class="string">/tools/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-screwdriver-wrench</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>/xxx/</code> 为菜单链接格式，<code>xxx</code> 为页面路径（项目 <code>source</code> 目录下的文件夹名称）</li><li><code>fas fa-home</code> 为 <a href="https://fontawesome.com/">Font Awesome</a> 图标，可以根据自己的需求更换图标</li><li><code>||</code> 为菜单链接和图标分隔符</li></ul><h2 id="CDN-内容源"><a href="#CDN-内容源" class="headerlink" title="CDN 内容源"></a>CDN 内容源</h2><p>为 <code>Butterfly</code> 提供图标源的 <code>jsdelivr</code> 在国内寄了，因此需要将 <code>CDN</code> 改为本地并按提示安装 <code>hexo-butterfly-extjs</code></p><ul><li>全文搜索 <code>CND</code> 快速定位</li><li><code>CDN.third_part_probider = jsdelivr</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CDN</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work</span></span><br><span class="line"><span class="comment"># 非必要請不要修改</span></span><br><span class="line"><span class="attr">CDN:</span></span><br><span class="line">  <span class="comment"># The CDN provider of internal scripts (主題內部 js 的 cdn 配置)</span></span><br><span class="line">  <span class="comment"># option: local/jsdelivr/unpkg/cdnjs/custom</span></span><br><span class="line">  <span class="comment"># Dev version can only choose. ( dev版的主題只能設置為 local )</span></span><br><span class="line">  <span class="attr">internal_provider:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The CDN provider of third party scripts (第三方 js 的 cdn 配置)</span></span><br><span class="line">  <span class="comment"># option: local/jsdelivr/unpkg/cdnjs/custom</span></span><br><span class="line">  <span class="comment"># when set it to local, you need to install hexo-butterfly-extjs</span></span><br><span class="line">  <span class="attr">third_party_provider:</span> <span class="string">jsdelivr</span>                                        <span class="comment"># 改为 local</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-butterfly-extjs</span>  <span class="comment"># 安装 hexo-butterfly-extjs</span></span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块中的所有功能只能用 Hexo 自带的代码渲染，如果使用第三方的渲染器，不一定有效。</p><ul><li><code>code_blocks.theme</code>：Butterfly 支持 6 种代码高亮样式，<code>darker</code>、<code>pale night</code>、<code>light</code>、<code>ocean</code>、<code>macStyle</code>、<code>false</code></li><li><code>code_blocks.code_word_wrap</code>：在默认情况下，Hexo 不会执行代码软换行，如果您不希望在代码块里有横向滚动条的话，则可以考虑使用这个功能 <code>code_word_wrap: true</code></li><li><code>code_blocks.highlight_height_limit</code>：单位是 <code>px</code>，直接添加数字，如 200，实际限制高度为 <code>highlight_height_limit + 30 px</code>，多增加 30px 限制，目的是避免代码高度只超出 <code>highlight_height_limit</code> 一点时，出现展开按钮，展开没内容</li></ul><h2 id="社交图标"><a href="#社交图标" class="headerlink" title="社交图标"></a>社交图标</h2><p>Butterfly 支持 <a href="https://fontawesome.com/">Font Awesome</a> 图标，在可以根据自己的需求更换图标，在 <code>_config.buttefly.yml</code> 中，格式为 <code>图标名: url || 描述性文字 || color</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">fab fa-github:</span> <span class="string">https://github.com/xxxxxx</span> <span class="string">||</span> <span class="string">Github</span> <span class="string">||</span> <span class="string">&quot;#hdhfbb&quot;</span></span><br><span class="line"><span class="attr">fas fa-envelope:</span> <span class="string">mailto:xxxxxx@gmail.com</span> <span class="string">||</span> <span class="string">Email</span> <span class="string">||</span> <span class="string">&quot;#00000&quot;</span></span><br></pre></td></tr></table></figure><h2 id="文章页"><a href="#文章页" class="headerlink" title="文章页"></a>文章页</h2><h3 id="Page-Post-Front-matter"><a href="#Page-Post-Front-matter" class="headerlink" title="Page&#x2F;Post Front-matter"></a>Page&#x2F;Post Front-matter</h3><p>Front-matter 翻译成中文是 【前页（指扉页、版权页、目次等）】，它位于 <code>Markdown</code> 文件的头部，遵循 <code>YAML</code> 语法的一块区域。</p><ul><li><code>Page Front-matter</code> 用于<code>主页文章卡片</code>配置</li><li><code>Post Front matter</code> 用于 <code>文章页</code> 配置</li></ul><p>在每篇博文的 markdown 文档顶部加上分割线 <code>---</code>，中间写上该文档的性质。具体写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line"><span class="section">updated:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><ul><li><code>Page Front-matter</code> 参数解释</li></ul><table><thead><tr><th>参数</th><th>解释</th><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必选】页面标题</td><td>data</td><td>【必选】页面创建日期</td></tr><tr><td>type</td><td>【必选】标签、分类和友情链接三个页面需要配置</td><td>updated</td><td>页面更新日期</td></tr><tr><td>description</td><td>页面描述</td><td>keywords</td><td>页面关键字</td></tr><tr><td>comments</td><td>显示页面评论模块（默认为 true）</td><td>top_img</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td>当 mathjax.per_pag&#x3D;false 时，才需要设置</td><td>katex</td><td>当 katex.per_page&#x3D;false 时，才需要设置</td></tr><tr><td>aside</td><td>显示侧边栏（默认为 true）</td><td>aplayer</td><td>在需要的页面加载 aplayer 的 js 和 css</td></tr><tr><td>highlight_shrink</td><td>配置代码框是否展开（默认为设置中 highlight_shrink 的配置）</td><td>random</td><td>配置友情链接是否随机排序</td></tr><tr><td>limit</td><td>配置说说显示数量</td><td>limit.type</td><td>配置说说显示数量的类型（date 或 num）</td></tr><tr><td>limit.value</td><td>配置说说显示数量的值</td><td></td><td></td></tr></tbody></table><ul><li><code>Post Front-matter</code> 参数解释</li></ul><table><thead><tr><th>参数</th><th>解释</th><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必选】文章标题</td><td>data</td><td>【必选】文章创建日期</td></tr><tr><td>updated</td><td>文章更新日期</td><td>tags</td><td>文章标签</td></tr><tr><td>categories</td><td>文章分类</td><td>keywords</td><td>文章关键字</td></tr><tr><td>description</td><td>文章描述</td><td>top_img</td><td>文章顶部图片</td></tr><tr><td>cover</td><td>文章缩略图（如果没有设置 top_img，文章页顶部将显示缩略图，可设为 false&#x2F;图片地址&#x2F;留空）</td><td>comments</td><td>显示文章评论模块</td></tr><tr><td>toc</td><td>显示文章 TOC（默认为设置中 toc 的 enable 设置）</td><td>toc_number</td><td>显示 toc_number（默认为设置中 toc 的 number 设置）</td></tr><tr><td>toc_style_simple</td><td>显示 toc 简洁模式</td><td>copyright</td><td>显示文章版权模块</td></tr><tr><td>copyright_author</td><td>文章版权模块的文章作者</td><td>copyright_author_href</td><td>文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>文章版权模块的文章连接链接</td><td>copyright_info</td><td>文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>当 mathjax.per_pag&#x3D;false 时，才需要设置</td><td>katex</td><td>当 katex.per_page&#x3D;false 时，才需要设置</td></tr><tr><td>aside</td><td>显示侧边栏（默认为 true）</td><td>aplayer</td><td>在需要的页面加载 aplayer 的 js 和 css</td></tr><tr><td>highlight_shrink</td><td>配置代码框是否展开（默认为设置中 highlight_shrink 的配置）</td><td>abcjs</td><td>当设置 abcjs.per_page&#x3D;false 时，才需要配置</td></tr><tr><td>noticeOutdate</td><td>文章过期提醒（默认为设置中 noticeOutdate 的 enable 设置）</td><td></td><td></td></tr></tbody></table><h3 id="TOC-目录"><a href="#TOC-目录" class="headerlink" title="TOC 目录"></a>TOC 目录</h3><p>在侧边栏显示 TOX（文章目录）：</p><ul><li><code>toc.post</code>：文章页是否显示 TOC</li><li><code>toc.page</code>：普通页面是否显示 TOC</li><li><code>toc.number</code>：是否显示章节数</li><li><code>toc.expand</code>：是否展开 TOC</li><li><code>toc.style_simple</code>：简洁模式（侧边栏只显示 TOC，只对文章页有效）</li><li><code>toc.scroll_percent</code>：是否显示滚动进度百分比</li></ul><p>在你的文章 <code>md</code> 文件的头部，加入 <code>toc_number</code> 和 <code>toc</code>，并配置 <code>true</code> 或者 <code>false</code> 即可。主题会优先判断文章 Markdown 的 Front-matter 是否有配置，如有，则以 Front-matter 的配置为主。否则，以<strong>主题配置文件中</strong>的配置为主。</p><h3 id="文章编辑按钮"><a href="#文章编辑按钮" class="headerlink" title="文章编辑按钮"></a>文章编辑按钮</h3><p>在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Post edit</span></span><br><span class="line"><span class="comment"># Easily browse and edit blog source code online.</span></span><br><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/</span></span><br><span class="line">  <span class="comment"># For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/</span></span><br><span class="line">  <span class="attr">url:</span></span><br></pre></td></tr></table></figure><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><blockquote><p>当文章封面设置为 false 时，或者没有获取到封面配置，相关文章背景将会显示主题色</p></blockquote><p>相关文章推荐的原理是根据文章 tags 的比重来推荐</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期显示创建日或者更新日</span></span><br></pre></td></tr></table></figure><h2 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h2><ul><li><p><code>source</code> 中的每一个目录就是一个页面，<code>_prots</code>、<code>_draft</code> 除外</p></li><li><p>目录包含的页面</p><blockquote><p>需要本地填写</p></blockquote></li><li><p><code>内建页面</code>不需要在本地创建任何目录，它由 <code>Butterfly</code> 自动生成；</p></li><li><p><code>普通页面</code> 直接使用 <code>hexo new page</code> 新建即可，普通页面的名称、内容不受约束；</p></li><li><p><code>关联页面</code> 则需要使用 <code>hexo new page</code> 新建，必须是 <code>Butterfly</code> 支持的页面，需要添加头部 <code>YAML</code>，文章不可包含内容</p></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure><p><code>tags/index.md</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2022-02-05 18:29:52</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line"><span class="section">layout: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="Search-搜索"><a href="#Search-搜索" class="headerlink" title="Search 搜索"></a>Search 搜索</h2><p>安装 <code>hexo-generator-search</code> 用于本地搜索</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-search</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>全文搜索 <code># search</code> 快速定位，设置 <code>local_search.enable = true</code>，该配置需要 <code>hexo clean</code></p><h2 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h2><p>标签外挂是 Hexo 独有的功能，并不是标准的 Markdown 格式。以下的写法，只适用于 Butterfly 主题，用在其它主题上不会有效果，甚至可能会报错，使用前请留意。</p><h3 id="Image-图片"><a href="#Image-图片" class="headerlink" title="Image 图片"></a>Image 图片</h3><p>这个在<a href="https://butterfly.js.org/posts/4aa8abbe/#%E9%A0%AD%E5%83%8F">Butterfly 文档（三）主题配置</a>有详细介绍</p><p>这里选一部分介绍</p><ul><li>静止彩带背景</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># canvas_ribbon (静止彩带背景)</span></span><br><span class="line"><span class="comment"># See: https://github.com/hustcc/ribbon.js</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>默认暗黑主题</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default display mode (网站默认的显示模式)</span></span><br><span class="line"><span class="comment"># light (default) / dark</span></span><br><span class="line"><span class="attr">display_mode:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><ul><li>首页循环打字</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主页subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js (配置typed.js)</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span> <span class="string">loop</span></span><br><span class="line">  <span class="comment"># source 调用第三方服务</span></span><br><span class="line">  <span class="comment"># source: false 关闭调用</span></span><br><span class="line">  <span class="comment"># source: 1  调用一言网的一句话 https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  调用随机一句话 https://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  调用今日诗词 https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 会先显示 source , 再显示 sub 的内容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">找点好玩的去~</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">搞点好吃的去~</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">遇事不决，埋头就睡。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Hey!</span> <span class="string">你在看什么？</span></span><br></pre></td></tr></table></figure><h3 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h3><p>参考链接：<a href="https://www.fattymonkey.com/post/10066.html#post-comment">https://www.fattymonkey.com/post/10066.html#post-comment</a></p><p>相册集是 Butterfly 主题的一个亮点，能够在博客中展示各种各样的自定义图片。</p><h4 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h4><p>首先新建相册页面</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page gallery</span><br></pre></td></tr></table></figure><p>这样就会在 <code>Hexo</code> 博客的根目录下的 <code>/source</code> 下生成 <code>/gallary/index.md</code> 文件，<code>gallery</code> 可以是自定义的任意单词！在 <code>index.md</code> 文件中 <code>Front-matter</code> 中，将侧边栏和评论区设置未 false。</p><p>点击首页菜单栏的 <code>相册</code> 即可进入相册首页</p><p>可见，此时的相册页面是什么都没有的，只有一个用来展示内容的空白框！</p><h4 id="图库集合页面"><a href="#图库集合页面" class="headerlink" title="图库集合页面"></a>图库集合页面</h4><p>一个图库集合，图库集合页面就是普通的页面，如上面创建的 <code>/gallery/index.md</code>，写法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup &#123;name&#125; &#123;description&#125; &#123;link&#125; &#123;img-url %&#125;&#125;</span><br><span class="line">&#123;% galleryGroup &#123;name&#125; &#123;description&#125; &#123;link&#125; &#123;img-url&#125; %&#125;</span><br><span class="line">&#123;% galleryGroup &#123;name&#125; &#123;description&#125; &#123;link&#125; &#123;img-url&#125; %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th align="left">解释</th></tr></thead><tbody><tr><td>name</td><td align="left">图库名字</td></tr><tr><td>description</td><td align="left">图库描述</td></tr><tr><td>link</td><td align="left">链接到对应相册的地址</td></tr><tr><td>link-url</td><td align="left">图库封面的地址</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;收藏的一些壁纸，侵删&#x27; &#x27;/album/wallpaper&#x27; https://www.czblogs.cn/album/wallpaper.jpeg %&#125;</span><br></pre></td></tr></table></figure><h4 id="图库子页面"><a href="#图库子页面" class="headerlink" title="图库子页面"></a>图库子页面</h4><p>此时，我们还没有创建相应的子页面，此时点开任何一个图集，都会定向到 <code>404</code> 页面，现在需要为这个相册创建子页面</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page life</span><br></pre></td></tr></table></figure><p>然后会在博客根目录下 <code>/source</code> 目录下生成名为 <code>life</code> 的文件夹，并在其中生成一个名为 <code>index.md</code> 的文件，这个文件对应<code>生活</code>这个子页面！</p><p>此时图库子页面<code>/source/life/index.md</code> 和相册首页 <code>/source/gallery/index.md</code> 是平级的，需要将 <code>life</code> 整个文件夹移动到 <code>gallery</code> 文件夹中。然后在子页面 <code>/source/gallery/life/index.md</code> 中使用标签外挂挂上自己的照片，写法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery [button] %&#125;</span><br><span class="line">![](<span class="link"></span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>button：点击按钮加载更多的图片，填写 true&#x2F;false，默认为 false</p></blockquote><p>注意点：</p><ul><li>这里使用的是外挂标签，其中的图片就是按照 Markdown 插入图片的格式书写的，这个标签外挂会自动根据图片的尺寸大小来调整图片的大小，我们只需要将图片罗列上去。</li><li>由于标签外挂 <code>gallery</code> 会实时监测页面尺寸的大小，然后不断地变更图片的尺寸，所以当我们放入图库子页面所有的图片尺寸不一致时，有可能会导致显示图片的页面元素的尺寸不断变化，从视觉上看就是一直在抖动</li></ul><h3 id="Tig-hide"><a href="#Tig-hide" class="headerlink" title="Tig-hide"></a>Tig-hide</h3><p>如果想把一些文字，内容隐藏起来，并提供按钮让用户<code>点击展示</code>，可以使用这种标签外挂。</p><p><code>inline</code> 在文本里面添加隐藏内容，仅限文字，<code>content</code> 不能包含英文逗号，可用 <code>&amp;sbquo</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>content</td><td>文本内容</td></tr><tr><td>display</td><td>【可选】按钮提示的文字</td></tr><tr><td>bg</td><td>【可选】按钮的背景颜色</td></tr><tr><td>color</td><td>【可选】按钮文字的颜色</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哪个英文字母最酷？ &#123;% hideInline 因为西装库（C装酷）,查看答案,#FF7242,#FFF %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Butterfly 安装与部署</title>
      <link href="/2024/11/27/%E6%95%99%E7%A8%8B/hexo-butterfly-blog/"/>
      <url>/2024/11/27/%E6%95%99%E7%A8%8B/hexo-butterfly-blog/</url>
      
        <content type="html"><![CDATA[<p><code>Hexo</code> 是一个快速、简洁且高效的博客框架，基于 <code>Node.js</code> 开发，支持 <code>Markdown</code> 编写文章，支持主题和插件扩展，可以快速搭建一个博客网站。<code>Hexo</code> 的社区活跃，不仅有很多优秀的主题和插件可供选择，而且可以在此基础上满足更多的个性化需求</p><p><code>Butterfly</code> 是一个简介、优雅的主题，支持多种配置、插件和功能，适合个人站点使用。</p><p><code>hexo-theme-butterfly</code> 是基于 <code>hexo-theme-melody</code> 的基础上进行开发的主题。</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><h3 id="安装-Hexo-及-Butterfly-主题"><a href="#安装-Hexo-及-Butterfly-主题" class="headerlink" title="安装 Hexo 及 Butterfly 主题"></a>安装 Hexo 及 Butterfly 主题</h3><p>全局安装 Hexo</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br><span class="line">hexo <span class="literal">-v</span> <span class="comment"># 查看 hexo 版本号</span></span><br></pre></td></tr></table></figure><p>初始化个人博客，此操作后你的个人博客将成为你的默认博客目录，之后所有 <code>hexo</code> 命令都默认在该目录执行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#123;博客名称&#125;</span><br><span class="line"><span class="built_in">cd</span> &#123;博客名称&#125;</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>博客内容：</p><ul><li><code>source</code>：页面与文章目录，内部的 <code>_posts</code> 用于存放文章，可以看到里面已经有了一个 <code>hello-world.md</code>。</li><li><code>themes</code>：主题目录</li><li><code>public</code>：静态网页文件目录</li><li><code>_config.yml</code>：博客信息配置文件</li></ul><p>在 Hexo 项目中安装 <code>Butterfly</code> 主题，在项目根目录执行下面命令会将 <code>Butterfly</code> 主题下载到 <code>themes/butterfly</code> 目录下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> master https://github.com/jerryc127/hexo<span class="literal">-theme-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改 Hexo 项目的 <code>_config.yml</code> 文件，将 <code>theme</code> 配置项修改为 <code>butterfly</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>如果没有 <code>pug</code> 以及 <code>stylus</code> 的渲染器，需要安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>后续升级建议：为了减少升级主题带来的不便，建议将主题配置文件 <code>themes/butterfly/_config.yml</code> 复制一份到 hexo 的根目录并重命名为 <code>_config.butterfly.yml</code>，之后所有的主题相关配置都在 <code>_config.butterfly.yml</code> 中修改即可</p><blockquote><p>注意：</p><p>复制的是主题的 <code>_config.yml</code>，而不是 hexo 的 <code>_config.yml</code></p><p>不要把主题目录的 <code>_config.yml</code> 删掉</p><p><code>Hexo</code> 会自动合并主题中的 <code>_config.yml</code> 文件和根目录下的 <code>_config.butterfly.yml</code> 主题配置内容，且 <code>_config.butterfly.yml</code> 主题文件配置优先级更高</p></blockquote><h2 id="Hexo-部署"><a href="#Hexo-部署" class="headerlink" title="Hexo 部署"></a>Hexo 部署</h2><h3 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h3><ul><li>生成静态网页到 <code>public</code> 目录</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate &amp; hexo g</span><br></pre></td></tr></table></figure><ul><li>启动本地预览服务器（实时更新）（https 不可用）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server &amp; hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a>，即可查看 <code>Hexo</code> 博客网站。</p><ul><li>部署服务器到远端</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy &amp; hexo d</span><br></pre></td></tr></table></figure><ul><li>新建文章到 <code>source/_posts</code> 目录（可以手动新建，但注意 Markdown 头部声明）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#123;文章名称&#125;</span><br></pre></td></tr></table></figure><ul><li>新建页面到 <code>source</code> 目录</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &#123;页面名称&#125;</span><br></pre></td></tr></table></figure><ul><li>清除 <code>hexo</code> 博客目录缓存与 <code>public</code> 目录，用于修复未知问题</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="built_in">clear</span> &amp; hexo c</span><br></pre></td></tr></table></figure><h3 id="配置博客信息"><a href="#配置博客信息" class="headerlink" title="配置博客信息"></a>配置博客信息</h3><p>前面讲到 <code>_config.yml</code> 文件用于配置博客信息，这里我们打开 <code>_config.yml</code>，仅对于我们关心的内容进行讲解，详细内容见官方文档 <a href="https://hexo.io/zh-cn/docs/configuration.html">_config.yml</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo                                        # 博客标题: Jamhus Tao&#x27;s Blog</span><br><span class="line">subtitle: &#x27;&#x27;                                    # 博客副标题，可缺省</span><br><span class="line">description: &#x27;&#x27;                                    # 博客描述，显示在作者下方</span><br><span class="line">keywords:                                        # 关键词</span><br><span class="line">author: John Doe                                # 作者: Jamhus Tao</span><br><span class="line">language: en                                    # 语言: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;                                    # 时区: &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure><h3 id="创建-Github-仓库"><a href="#创建-Github-仓库" class="headerlink" title="创建 Github 仓库"></a>创建 Github 仓库</h3><p>配置 <code>Hexo</code> 的方式其实有两种，一种是使用个人服务器，另一种是使用 <code>Github</code> 提供的免费服务，这里主要介绍后者的部署过程。</p><ul><li>首先新建一个名为 <code>&#123;用户名&#125;.github.io</code> 的仓库</li><li>配置 <code>git</code> 工具与 <code>github</code> 建立可信任连接</li></ul><h4 id="配置自定义域名（可选）"><a href="#配置自定义域名（可选）" class="headerlink" title="配置自定义域名（可选）"></a>配置自定义域名（可选）</h4><ul><li>如果觉得 <code>xxx.github.io</code> 太 low 了，可以花钱购买自定义域名，购买域名可以到 <code>阿里云</code> 等平台，一般的域名大概每年几十元。</li><li>打开平台的域名解析界面，添加 <code>CNAME</code> 记录，全部指向你的 <code>xxx.github.io</code>。</li><li>打开 <code>github</code> 仓库，将 <code>Setting-Pages-Custom domain</code> 设置为你购买的域名。</li><li>在本地博客目录下的 <code>source</code> 目录创建 <code>CNAME</code> 文件（没有后缀名），使用记事本打开，写入你购买的域名。</li></ul><h4 id="部署个人站点"><a href="#部署个人站点" class="headerlink" title="部署个人站点"></a>部署个人站点</h4><p>在 <code>hexo</code> 的 <code>_config.yml</code> 找到 <code>URL</code> 和 <code>Deployment</code> 配置。在 <code>url</code> 写上个人站点，如果配置了自定义域名则写上购买的域名，不然写上 <code>xxx.github.io</code>。在 <code>deploy.type</code> 写上 <code>git</code>，后面还得加上 <code>repository</code> 和 <code>branch</code> 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://&#123;username&#125;.github.io</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span>                                                       <span class="comment"># 部署方式: sftp / git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/&#123;username&#125;/&#123;username&#125;.github.io</span>    <span class="comment"># 仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span>                                                  <span class="comment"># 仓库分支</span></span><br></pre></td></tr></table></figure><blockquote><p>注：SFTP 用于推送至个人服务器</p></blockquote><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>第一次需要安装 <code>git</code> 部署方式依赖</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span>  <span class="comment"># 首先安装 git 部署方式依赖</span></span><br></pre></td></tr></table></figure><p>再执行部署</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次最好运行这三个</span></span><br><span class="line"><span class="comment"># 清空缓存与静态文件；重新生成静态文件；开始部署站点</span></span><br><span class="line">hexo c &amp; hexo g &amp; hexo d</span><br></pre></td></tr></table></figure><p>现在使用浏览器打开 <code>&#123;username&#125;.github.io</code>，可以看到和本地运行时相同的界面。</p><blockquote><p>注：将站点部署到 Github 后不会立即生效属于正常现象，Github 需要将代码仓库中的文件部署到自己的服务器上</p></blockquote><blockquote><p>之后每次部署站点，都需要用到这些命令。不同的是，如果修改了网站配置，最好运行 <code>hexo clean</code> 命令；日常上传文章不需要运行该命令</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIOps 简介</title>
      <link href="/2024/11/02/%E8%B0%83%E7%A0%94/aiops/"/>
      <url>/2024/11/02/%E8%B0%83%E7%A0%94/aiops/</url>
      
        <content type="html"><![CDATA[<p>AIOps（Artificial Intelligence for IT Operations， 智能运维）是指利用人工智能技术，精准地管控和分析 IT 系统中的海量运维数据，并通过自动化、智能化的方式来优化运维流程，提高运维效率和运维质量。</p><p>AIOps 的特点是利用机器学习、深度学习等 AI 技术，对运维类数据进行分析和处理，从而对运维目标进行健康度评估、智能定位和异常分析，甚至发现潜在问题，提升目标系统的可用性和稳定性。</p><p>AIOps 将会成为 IT 运维的重要发展方向，帮助企业更加高效、智能地实现<strong>数字化转型</strong>。</p><h3 id="为什么要使用-AIOps"><a href="#为什么要使用-AIOps" class="headerlink" title="为什么要使用 AIOps"></a>为什么要使用 AIOps</h3><p>IT 系统先后经历了人工运维和自动化运维阶段，正向智能运维方向演进。在人工运维阶段，主要依赖运维专家的工作经验来进行故障分析、定位和排障，整体运维效率不高，且需要长时间的积累。在自动化运维阶段，运维团队使用脚本、工具等方式执行运维任务，运维效率有了显著提升，但运维团队需要掌握自动化运维工具的开发和迭代，学习难度高。</p><p>随着当今社会信息化程度越来越高，人们的生活方式、社会组织形式、企业商业模式等都在不断发生变革。在这之后，IT 系统复杂度和规模不断增长，各种新技术和新架构层出不穷，各类数据呈爆炸式增长。这些极大挑战现有的 IT 运维能力。面对海量数据、不停变化的系统状态、繁多的业务应用和不同的配置参数，运维工程师的精力有限，人工运维和自动化运维的手段和理念已经无法满足当今大规模 IT 系统的运维诉求。</p><p>为此，Gartner 于 2016 年提出了 AIOps（智能运维）的概念。AIOps 平台通过大数据、机器学习、人工智能等技术，自动地学习和分析海量运维数据（包含历史数据、日志数据、业务数据、系统数据等），给出运维决策建议，可增强和部分取代现有的运维流程和操作。AIOps 可以满足大规模 IT 系统的运维诉求。</p><h3 id="AIOps-使用案例："><a href="#AIOps-使用案例：" class="headerlink" title="AIOps 使用案例："></a>AIOps 使用案例：</h3><ul><li><p>应用程序性能监控：使用传统方法从现代场景中收集指标具有挑战性，例如微服务、API 和数据存储等组件之间的数据交换。取而代之的是，软件团队使用人工智能进行应用程序性能监控，以大规模收集和编译相关指标。</p></li><li><p>根因分析：人工智能技术能够快速处理大数据，在多个可能的原因之间建立关联，有效帮助人员确定事件的根本原因。可以有效调查影响系统性能的真正原因</p></li><li><p>异常检测：异常是偏离监控数据标准分布的异常值，通常指示影响系统运行的异常行为。AIOps 提供实时评估和预测功能，可快速检测数据偏差，并加快执行纠错措施。IT 团队可以设置基于规则的策略以自动执行补救措施</p></li><li><p>云自动化和优化：AIOps 解决方案通过提供工作负载的透明度、可观测性和自动化来支持云转型。在管理相互依赖关系时，部署和管理云应用程序需要更大的灵活性和敏捷性。组织使用 AIOps 解决方案按需配置和扩展计算资源。例如，使用 AIOps 监控工具来计算云使用量并增加容量以支持流量增长</p></li><li><p>应用程序开发支持：DevOps 团队使用 AIOps 工具来提高代码质量。他们可以自动进行代码审查，应用编程最佳实践，以及在开发阶段的早期检测错误。AIOps 工具不是在开发周期接近结束时执行代码质量检查，而是尽量提前检查。</p></li></ul><h3 id="AIOps-和其它术语之间的区别："><a href="#AIOps-和其它术语之间的区别：" class="headerlink" title="AIOps 和其它术语之间的区别："></a>AIOps 和其它术语之间的区别：</h3><p>AIOps 是相对较新的概念，它促使机器学习和大数据处理来改善 IT 运营，以下是 AIOps 与几个相关术语的比较：</p><ul><li>AIOps 与 DevOps<ul><li>DevOps 是一种软件实践，弥合了开发和支持工作流程之间的差距。DevOps 通过在软件和运营团队之间共享信息，帮助组织应用更改并快速解决用户问题。</li><li>AIOps 是一种使用人工智能技术来支持现有 IT 流程的方法；DevOps 团队使用 AIOps 工具来持续评估编码质量并缩短软件交付时间</li></ul></li><li>AIOps 与 MLOps<ul><li>MLOps 框架可以帮助软件团队将机器学习模型集成到数字产品中。该框架涉及模型选型和数据准备。它包括在生产环境中训练、评估和部署机器学习应用程序的过程。</li><li>AIOps 会应用机器学习解决方案来生成可行的见解并提高新 IT 系统和现有 IT 系统的流程效率。</li></ul></li><li>AIOps 与 SRE<ul><li>SRE 是一种工程团队可用于自动化系统操作和使用软件工具执行检查的方法。SRE 团队不依赖手动方法，而是通过自动检测和解决问题来改善软件可靠性和客户体验</li><li>AIOps 与 SRE 有着重叠的目标。AIOps 使用业务运营的海量数据和基于机器学习的预测性见解来帮助站点可靠性工程师缩短事件解决时间</li></ul></li><li>AIOps 与 DataOps<ul><li>借助 DataOps 计划，组织可优化商业智能应用程序的数据使用情况。DataOps 涉及设置数据管道，数据工程师可以使用这些管道从不同域提取、转换和传输数据，以此支持业务运营</li><li>与此同时，AIOps 是一种更为复杂的实践。AIOps 使用 DataOps 提供的信息来检测、分析和解决事件</li></ul></li></ul><h3 id="华为在数据通信领域中的-AIOps-平台和方案"><a href="#华为在数据通信领域中的-AIOps-平台和方案" class="headerlink" title="华为在数据通信领域中的 AIOps 平台和方案"></a>华为在数据通信领域中的 AIOps 平台和方案</h3><p>iMaster NCE 系列产品，全面覆盖各类网络的“规划、建设、维护、优化”的全生命周期，AIOps 智能运维是其中重要的一环。</p><p>以华为数据中心网络为例，在智能运维阶段实现的能力包括但不限于：</p><ul><li>变更及扩容阶段：业务变更意图识别、自动推荐变更方案、变更下发前仿真评估、变更下发后可按需回滚、自动生成验收报告。</li><li>监控阶段：基于业务视图自动创建监控任务，持续监控。</li><li>排障阶段：实时识别异常，1 分钟发现问题、自动分析故障根因、推荐最佳修复方案、预测软硬件故障。</li><li>调参优化阶段：根据流量模型，自动调整设备内部队列，实现 0 丢包；建立业务质量的动态基线，可提前预测业务的劣化。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/AIOps.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/AIOps.html</a><br><a href="https://aws.amazon.com/cn/what-is/aiops/">https://aws.amazon.com/cn/what-is/aiops/</a></p>]]></content>
      
      
      <categories>
          
          <category> 调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages 数学公式显示</title>
      <link href="/2024/11/02/%E7%89%87%E6%AE%B5/github-pages-mathtype/"/>
      <url>/2024/11/02/%E7%89%87%E6%AE%B5/github-pages-mathtype/</url>
      
        <content type="html"><![CDATA[<p>使用 Github Pages 发布博文时，当我们的 markdown 文件出现数学公式时,Github Page 里的 Jekyll 虽然支持 markdown，但不能正常显示数学公式，可以借助 MathJax 帮助渲染，具体做法是添加以下代码到 markdown 文件的开头，这样发布的博文就可以正常显示了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">MathJax</span>.<span class="property">Hub</span>.<span class="title class_">Config</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">tex2jax</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">skipTags</span>: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">inlineMath</span>: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>]]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 片段 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
